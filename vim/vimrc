" Plugins
set nocompatible

if has('nvim')
	call plug#begin('~/.config/nvim/plugged')
	Plug 'Shougo/deoplete.nvim'
	Plug 'fishbullet/deoplete-ruby'
else
	call plug#begin('~/.vim/plugged')
	Plug 'Shougo/neocomplete.vim' " Autocomplete (with tab)
	Plug 'Shougo/vimproc.vim', { 'do' : 'make'  }
endif

	Plug 'Konfekt/FastFold' " Update folding only when necessary

	"Plug 'majutsushi/tagbar' "See functions, methods, etc

	" Identation guides
	"Plug 'Yggdroot/indentLine'
	"Plug 'nathanaelkane/vim-indent-guides'

	" Solarized color scheme
	"Plug 'altercation/vim-\colors-solarized'
	Plug 'iCyMind/NeoSolarized'

	Plug 'vim-airline/vim-airline' "Nice status line
	Plug 'vim-airline/vim-airline-themes'

	Plug 'mbbill/undotree' "More efficient undo tree

	Plug 'kshenoy/vim-signature' "Show marks

	"Plug 'christoomey/vim-tmux-navigator' "Tmux + Vim integration

	Plug 'easymotion/vim-easymotion' "faster motions by highlighting all possible destinations

	"Plug 'ervandew/supertab'

	Plug 'jiangmiao/auto-pairs'
	"Plug 'raimondi/delimitmate' " Auto close braces, etc

	"Plug 'myusuf3/numbers.vim' " Relative/non-relative numbers depending on mode

	Plug 'djoshea/vim-autoread' " Reload files if they change on disk and buffer wasn't modified

	Plug 'jlanzarotta/bufexplorer' " Easily navigate buffers using \be, \bv, \bs

	"Plug 'guns/xterm-color-table.vim'

	"Linter
	Plug 'scrooloose/syntastic'

	" Easily align to symbol
	Plug 'junegunn/vim-easy-align'

	" Fuzzy finder
	Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }
	Plug 'junegunn/fzf.vim'

	" i3 status syntax
	Plug 'PotatoesMaster/i3-vim-syntax'

	" Tree file browser
	Plug 'scrooloose/nerdtree'
	Plug 'Xuyuanp/nerdtree-git-plugin'

	" Allow to close buffers without closing split
	Plug 'qpkorr/vim-bufkill'
call plug#end()

" Color, theme
set background=dark
"colorscheme solarized
colorscheme NeoSolarized

" Line numbering
set number
"set relativenumber

" Highlight current line
set cursorline

" 3 spaces, no tabs
set tabstop=4
set softtabstop=4
set shiftwidth=4
set autoindent
set smartindent "This copies from previous line and does not interfere with filetype
"set expandtab

au FileType python setl shiftwidth=3 softtabstop=3 expandtab
au FileType mips setl shiftwidth=3 softtabstop=3 expandtab

" Disable automatic comment on next line
autocmd BufNewFile,BufRead * setlocal formatoptions-=ro

" Key timeouts
set timeoutlen=1000 ttimeoutlen=0

" Scrolling
set mouse+=a

"Fix mouse for tmux (resizing splits)
if (!has('nvim'))
	if has("mouse_sgr")
		set ttymouse=sgr
	else
		set ttymouse=xterm2
	end
endif

" Live command preview
if (has('nvim'))
	set inccommand=nosplit
endif

" Backspace deletes in insert mode
set backspace=2

" Colors
set t_Co=256

" Incremental Search
set incsearch

" Highlight all search matches
set hlsearch

" Color column 132
" because customer-facing code should have max width of 132
set colorcolumn=132

" Key bindings
map <leader>y "*y
map <leader>Y "*Y
map <leader>s "*s
map <leader>S "*S
map <leader>d "*d
map <leader>d "*d
map <leader>x "*x
map <leader>X "*X
map <leader>c "*c
map <leader>C "*C
map <leader>p "*p
map <leader>P "*P

" Use bash for shell commands and scripts (faster)
set shell=bash

" File types
"
au bufread,bufnewfile *.mv set filetype=verilog
au bufread,bufnewfile *.sv set filetype=verilog
au bufread,bufnewfile *.vh set filetype=verilog
au bufread,bufnewfile *.svh set filetype=verilog
au bufread,bufnewfile *.prop set filetype=verilog
au bufread,bufnewfile *.prpl set filetype=verilog
au bufread,bufnewfile *.dpl set filetype=perl
au bufread,bufnewfile *.p set filetype=perl
au bufread,bufnewfile *.mrf set filetype=yaml
"systemc extended syntax
au bufread,bufnewfile *.cpp set syntax=systemc
au bufread,bufnewfile *.h set syntax=systemc
"golden files syntax
au bufread,bufnewfile *.gold set syntax=golden
"mips assembly
au bufread,bufnewfile *.S set filetype=mips syntax=mips

"set foldmethod=syntax
"set foldmethod=indent
"set foldmethod=manual
set nofoldenable
set foldlevelstart=99

" Allow opening of other files without closing buffers
set hidden

" Wild mode
set wildmode=full

" Persistent History
set undofile
set undodir=$HOME/.vimundo/
set undolevels=200 " not too big

" Show status line always
set laststatus=2

" Only redraw modified parts of the screen
set lazyredraw
"set ttyfast

" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
" Type z/ to toggle highlighting on/off.
nnoremap z/ :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
function! AutoHighlightToggle()
	let @/ = ''
	if exists('#auto_highlight')
		au! auto_highlight
		augroup! auto_highlight
		setl updatetime=4000
		echo 'Highlight current word: off'
		return 0
	else
		augroup auto_highlight
		au!
		au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
		augroup end
		setl updatetime=500
		echo 'Highlight current word: ON'
		return 1
	endif
endfunction

" Show tabs and spaces
"syntax match Blanks / / conceal cchar=Â·
let g:blanks_shown=1
function! ToggleShowBlanks()
	if g:blanks_shown
		let g:blanks_shown=0
		" Default values:
		hi SpecialKey ctermfg=237 ctermbg=NONE
		hi Conceal ctermfg=237 ctermbg=NONE
		set conceallevel=2
		set concealcursor=nvic
		set listchars=tab:>\ ,trail:Â·
		set list
		call clearmatches()
	else
		let g:blanks_shown=1
		hi SpecialKey ctermfg=240 ctermbg=NONE
		hi Conceal ctermfg=240 ctermbg=NONE
		set conceallevel=2
		set concealcursor=nvic
		set listchars=nbsp:Â·,trail:Â·,tab:>Â·,trail:~,extends:>,precedes:<,space:Â·
		set list
	endif
endfunction
command ShowBlanks call ToggleShowBlanks()
map <F2> :ShowBlanks<CR>
call ToggleShowBlanks()

"Remove Trailing blanks
command RemoveTrailing %s/\s\+$//

" Ctrl+hjkl split switching
inoremap <silent> <C-l> <c-w>l
inoremap <silent> <C-h> <c-w>h
inoremap <silent> <C-k> <c-w>k
inoremap <silent> <C-j> <c-w>j
nnoremap <silent> <C-l> <c-w>l
nnoremap <silent> <C-h> <c-w>h
nnoremap <silent> <C-k> <c-w>k
nnoremap <silent> <C-j> <c-w>j

inoremap <silent> <C-Right> <c-w>l
inoremap <silent> <C-Left> <c-w>h
inoremap <silent> <C-Up> <c-w>k
inoremap <silent> <C-Down> <c-w>j
nnoremap <silent> <C-Right> <c-w>l
nnoremap <silent> <C-Left> <c-w>h
nnoremap <silent> <C-Up> <c-w>k
nnoremap <silent> <C-Down> <c-w>j

nnoremap <silent> <C-a> :bp<CR>
nnoremap <silent> <C-d> :bn<CR>
nnoremap <silent> <C-s> :BD<CR>


"""""""
" Automatic title with file name

" Teach vim the tmux escape sequences for changing pane title
" Note the "^[" should be a literal escape code (use `^v<esc>` to enter it)
set t_ts=2;
set t_fs=\\

" Turn on setting the title.
set title

" The following causes vim to refresh the title each time we change buffers.
" Otherwise it will only set the title once at startup.
augroup RefreshTitle
  autocmd!
  " The concatenation of the colon is a hack to prevent vim from
  " interpreting the string as a modeline.
  autocmd BufEnter * let &titlestring = expand("%:t")
augroup END

""""""""""""""
" Indent ignoring blanks
""""""""""""""
function! IndentIgnoringBlanks(child)
	let lnum = v:lnum
	while v:lnum > 1 && getline(v:lnum-1) == ""
		normal k
		let v:lnum = v:lnum - 1
	endwhile
	if a:child == ""
		if ! &l:autoindent
			return 0
		elseif &l:cindent
			return cindent(v:lnum)
		endif
	else
		exec "let indent=".a:child
		if indent != -1
			return indent
		endif
	endif
	if v:lnum == lnum && lnum != 1
		return -1
	endif
	let next = nextnonblank(lnum)
	if next == lnum
		return -1
	endif
	if next != 0 && next-lnum <= lnum-v:lnum
		return indent(next)
	else
		return indent(v:lnum-1)
	endif
endfunction
command! -bar IndentIgnoringBlanks
			\ if match(&l:indentexpr,'IndentIgnoringBlanks') == -1 |
			\	if &l:indentexpr == '' |
			\	  let b:blanks_indentkeys = &l:indentkeys |
			\	  if &l:cindent |
			\		 let &l:indentkeys = &l:cinkeys |
			\	  else |
			\		 setlocal indentkeys=!^F,o,O |
			\	  endif |
			\	endif |
			\	let b:blanks_indentexpr = &l:indentexpr |
			\	let &l:indentexpr = "IndentIgnoringBlanks('".
			\	substitute(&l:indentexpr,"'","''","g")."')" |
			\ endif
command! -bar IndentNormally
			\ if exists('b:blanks_indentexpr') |
			\	let &l:indentexpr = b:blanks_indentexpr |
			\ endif |
			\ if exists('b:blanks_indentkeys') |
			\	let &l:indentkeys = b:blanks_indentkeys |
			\ endif
augroup IndentIgnoringBlanks
	au!
	au FileType * IndentIgnoringBlanks
augroup END

""""""""""""""
" Plugins
""""""""""""""

" TagBar
nmap <F4> :TagbarToggle<CR>

"Airline
set laststatus=2 "Show a status line always
let g:airline#extensions#tabline#enabled = 1 "Display all buffers
let g:airline#extensions#whitespace#enabled = 1 "Show whitespace
let g:airline#extensions#whitespace#checks = [ 'indent' ]
let g:airline_powerline_fonts = 1 "Powerline symbols (requires compatible font)
let g:airline_theme = 'molokai' "'solarized'

"Undo tree
nnoremap <F5> :UndotreeToggle<CR>

" Vim indent guides
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1

if has('nvim')
	" Use deoplete.
	let g:deoplete#enable_at_startup = 1"

	"inoremap <silent> <ESC> <C-r>=<SID>my_esc_function()<ESC>
	"function! s:my_esc_function() abort
	"	return deoplete#close_popup() . "\<ESC>"
	"endfunction
else
	" Neocomplete:
	let g:neocomplete#enable_at_startup = 1
	let g:acp_enableAtStartup = 0
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#enable_smart_case = 1
endif

" <TAB>: completion.
" TODO: Use a single function for mapping
function! Strip(input_string)
	return substitute(a:input_string, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction

function! GetTabCharacters()
	if &expandtab
		return repeat(' ', &tabstop)
	else
		return '\<Tab>'
	endif
endfunction

function! InsertModeTab()
	" If auto-complete is visible
	" insert current choice
	if pumvisible()
		return "\<C-n>"
	endif

	" Get current column
	let curcol = virtcol('.')

	" Check if line is empty or whitespace-only
	let line_empty = ( strlen(Strip(getline('.'))) <= 0 )

	if line_empty
		let curcindent = cindent('.')+1 " get C indent

		" If cursor is before cindent, add spaces until correct indent, then
		" delete rest of line
		if curcol < curcindent
			return "\<C-O>0\<C-O>\"_D" . repeat(GetTabCharacters(), (curcindent/&tabstop))

		" Otherwise, insert a Tab
		else
			return GetTabCharacters()
		endif

	else
		let curindent = indent('.')+1 " get indent of existing text

		" If cursor is before current indent, go to first character in line
		if curcol < curindent
			return "\<C-O>^"

		" Otherwise, insert a tab
		else
			return GetTabCharacters()
		endif
	endif
endfunction

inoremap <expr><TAB> InsertModeTab()
nnoremap <expr><TAB> "i" . InsertModeTab()

" Use Tab/Shift-Tab to indent/unindent multiple lines at once in visual mode
vnoremap <expr><TAB>  ">gv"
vnoremap <expr><S-TAB> "<gv"

" indentLine
let g:indentLine_char = '|'

" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0

let g:syntastic_mode_map = { 'mode': 'passive', 'active_filetypes': ['python', 'ruby'] }
let g:syntastic_python_python_exec = 'python27'
"let g:syntastic_python_checkers = ['pylint']
"let g:syntastic_python_pylint_exec = 'python3-pylint'

" EasyAlign
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

"FZF
nnoremap <leader>b :Buffers<CR>
nnoremap <leader>g :GitFiles<CR>
nnoremap <C-P> :Files<CR>

" NERDtree
map <C-n> :NERDTreeToggle<CR>
let NERDTreeIgnore = ['\.pyc$']
" Start automatically if no files specified
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
" Start if opening a directory
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
" Close vim if only NERDtree left
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
