#########################################
# env/script_utils
# Author: Rui Pinheiro
#
# Utility methods for zsh script functions and methods

# Basic escape codes
typeset -g esc=$'\e[' rc=$'m'

################
# Colors
typeset -g fg256="${esc}38;5;" bg256="${esc}48;5;"

autoload -U colors && colors

function list_colors {
	i2=0
	for i in {0..255} ; do
		(( i2 += 1 ))
		echo -en "$fg_bold[black]"
		echo -en "${bg256}${i}${rc}${i}${reset_color}\t"
		
		if [[ "$i2" -eq 10 ]]; then
			echo -en "\n"
			i2=0
		fi
	done
	echo
}

function add_named_color {
	local name="$1" cnum="$2"

	fg[$name]="$fg256$cnum$rc"
	fg_bold[$name]="$fg256$cnum;$color[bold]$rc"
	fg_no_bold[$name]="$fg256$cnum;$color[normal]$rc"

	bg[$name]="$bg256$cnum$rc"
	bg_bold[$name]="$bg256$cnum;$color[bold]$rc"
	bg_no_bold[$name]="$bg256$cnum;$color[no_bold]$rc"
}

# Custom colors
add_named_color "purple" 13
add_named_color "lime" 154


#################
# Echo
function echo_error {
	echo "$fg_bold[red][$ZSH_SCRIPT_TITLE] ERROR: ${@}${reset_color}"
}

function echo_warn {
	echo "$fg[magenta][$ZSH_SCRIPT_TITLE] WARNING: ${@}${reset_color}"
}

function echo_info {
	echo "[$ZSH_SCRIPT_TITLE] ${@}${reset_color}"
}

function echo_debug {
	if is_true "$ZSH_SCRIPT_DEBUG"; then
		echo "$fg[cyan][$ZSH_SCRIPT_TITLE] ${@}${reset_color}"
	fi
}

# Echos command using echo_debug, then runs it
function echo_run {
	echo_debug "${@}"
	eval ${@}
}

#################
# Confirm something from user
function confirm_yn {
	read -q \?"$fg[white][$ZSH_SCRIPT_TITLE] $@ [yn] $reset_color"
	local retval=$?

	echo

	return $retval
}

#################
# Check if path is inside home
function path_in_home {
	local abs_path=$(readlink -f "$@")

	if [[ "$abs_path/" == "$HOME/"* ]]; then
		return 0
	fi

	return 1
}

#################
# Check if variable is not [unset, empty, "0"]
function is_true {
	local in=$(echo "$@:l" | xargs) # trim white-space

	if [[ -z "$in" ]] || # Unset or empty
	   [[ "$in" -eq "0" ]] # "0"
	then
		return 1
	fi

	return 0
}

#################
# Check if not is_true
function is_false {
	if is_true $1; then
		return 1
	fi

	return 0
}

#################
# Check if string is a valid integer
function is_int {
	if [[ "$@" =~ ^-?[0-9]+$ ]]; then
		return 0
	fi
	return 1
}

function is_uint {	if Ma[Ma "$@" =~ ^[Ma[0-9]+$ ]]; then
		return 0
	fi
	return 1
}

#################
# Check if executable is in path
function in_path {
	whence -w $1 >/dev/null
}
